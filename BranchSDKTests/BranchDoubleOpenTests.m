//
//  BranchDoubleOpenTests.m
//  Branch-SDK-Tests
//
//  Created for INTENG-21106: Double Open Fix
//  Tests for pendingSessionCallbacks coalescing and thread-safe status handling.
//

#import <XCTest/XCTest.h>
#import "Branch.h"
#import "BNCInitSessionResponse.h"

// Expose private properties for testing via KVC-equivalent category
@interface Branch (DoubleOpenTest)

@property (nonatomic, strong) NSMutableArray *pendingSessionCallbacks;
@property (nonatomic, strong, readwrite) dispatch_queue_t isolationQueue;

@end

@interface BranchDoubleOpenTests : XCTestCase
@property (nonatomic, strong) Branch *branch;
@end

@implementation BranchDoubleOpenTests

- (void)setUp {
    [super setUp];
    self.branch = [Branch getInstance];
}

- (void)tearDown {
    // Clear any callbacks left by tests
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    [callbacks removeAllObjects];
    self.branch = nil;
    [super tearDown];
}

#pragma mark - pendingSessionCallbacks Array Tests

- (void)testPendingSessionCallbacksIsInitialized {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    XCTAssertNotNil(callbacks, @"pendingSessionCallbacks should be initialized");
    XCTAssertTrue([callbacks isKindOfClass:[NSMutableArray class]], @"Should be NSMutableArray");
}

- (void)testPendingSessionCallbacksAccumulatesMultiple {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    NSUInteger initialCount = callbacks.count;

    void (^cb1)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) {};
    void (^cb2)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) {};
    void (^cb3)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) {};

    [callbacks addObject:[cb1 copy]];
    [callbacks addObject:[cb2 copy]];
    [callbacks addObject:[cb3 copy]];

    XCTAssertEqual(callbacks.count, initialCount + 3, @"Should accumulate 3 callbacks");
}

- (void)testPendingSessionCallbacksCopyAndClearPattern {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    [callbacks removeAllObjects];

    __block NSInteger invokeCount = 0;
    void (^cb1)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) { invokeCount++; };
    void (^cb2)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) { invokeCount++; };

    [callbacks addObject:[cb1 copy]];
    [callbacks addObject:[cb2 copy]];

    // Simulate the dispatch pattern used in handleInitSuccessAndCallCallback
    NSArray *snapshot = [callbacks copy];
    [callbacks removeAllObjects];

    XCTAssertEqual(callbacks.count, 0, @"Original array should be empty after clear");
    XCTAssertEqual(snapshot.count, 2, @"Snapshot should retain the 2 callbacks");

    // Dispatch all callbacks from snapshot
    BNCInitSessionResponse *response = [BNCInitSessionResponse new];
    for (void (^callback)(BNCInitSessionResponse *, NSError *) in snapshot) {
        callback(response, nil);
    }

    XCTAssertEqual(invokeCount, 2, @"Both callbacks should have been invoked");
}

- (void)testPendingSessionCallbacksErrorDispatch {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    [callbacks removeAllObjects];

    __block NSInteger errorCount = 0;
    __block NSError *receivedError1 = nil;
    __block NSError *receivedError2 = nil;

    void (^cb1)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) {
        errorCount++;
        receivedError1 = e;
    };
    void (^cb2)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) {
        errorCount++;
        receivedError2 = e;
    };

    [callbacks addObject:[cb1 copy]];
    [callbacks addObject:[cb2 copy]];

    // Simulate the dispatch pattern used in handleInitFailure
    NSArray *snapshot = [callbacks copy];
    [callbacks removeAllObjects];

    NSError *testError = [NSError errorWithDomain:@"io.branch.test" code:1001 userInfo:@{NSLocalizedDescriptionKey: @"Test failure"}];
    BNCInitSessionResponse *response = [BNCInitSessionResponse new];
    response.error = testError;

    for (void (^callback)(BNCInitSessionResponse *, NSError *) in snapshot) {
        callback(response, testError);
    }

    XCTAssertEqual(errorCount, 2, @"Both callbacks should receive the error");
    XCTAssertEqualObjects(receivedError1.domain, @"io.branch.test");
    XCTAssertEqualObjects(receivedError2.domain, @"io.branch.test");
    XCTAssertEqual(receivedError1.code, 1001);
}

- (void)testPendingSessionCallbacksEmptyArraySafeDispatch {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    [callbacks removeAllObjects];

    // Simulate dispatching with empty array (no crash expected)
    if (callbacks.count > 0) {
        XCTFail(@"Should not enter dispatch block with empty array");
    }

    // The guard `if (self.pendingSessionCallbacks.count > 0)` prevents dispatch
    XCTAssertEqual(callbacks.count, 0, @"Empty array should be safe");
}

#pragma mark - Thread Safety: handleDeepLink Status Reset

- (void)testHandleDeepLinkDoesNotResetStatusOnMainThread {
    // Set initializationStatus to Initializing (1) via KVC
    [self.branch setValue:@(1) forKey:@"initializationStatus"];

    NSInteger statusBefore = [[self.branch valueForKey:@"initializationStatus"] integerValue];
    XCTAssertEqual(statusBefore, 1, @"Status should be Initializing (1)");

    // Call handleDeepLink: on main thread
    NSURL *url = [NSURL URLWithString:@"https://example.app.link/test"];
    [self.branch handleDeepLink:url];

    // Check status IMMEDIATELY on main thread (synchronous check)
    // Old bug: status was reset to 0 (Uninitialized) synchronously on main thread.
    // Fix: the main-thread reset was removed; status only changes inside isolationQueue.
    NSInteger statusAfter = [[self.branch valueForKey:@"initializationStatus"] integerValue];
    XCTAssertNotEqual(statusAfter, 0,
        @"initializationStatus should NOT be reset to Uninitialized (0) on main thread. "
         "The reset:YES parameter handles this safely inside isolationQueue.");
}

#pragma mark - Callback Response Integrity

- (void)testAllCallbacksReceiveSameResponse {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    [callbacks removeAllObjects];

    __block BNCInitSessionResponse *response1 = nil;
    __block BNCInitSessionResponse *response2 = nil;
    __block BNCInitSessionResponse *response3 = nil;

    [callbacks addObject:[^(BNCInitSessionResponse *r, NSError *e) { response1 = r; } copy]];
    [callbacks addObject:[^(BNCInitSessionResponse *r, NSError *e) { response2 = r; } copy]];
    [callbacks addObject:[^(BNCInitSessionResponse *r, NSError *e) { response3 = r; } copy]];

    NSArray *snapshot = [callbacks copy];
    [callbacks removeAllObjects];

    BNCInitSessionResponse *response = [BNCInitSessionResponse new];
    response.params = @{@"test_key": @"test_value"};

    for (void (^callback)(BNCInitSessionResponse *, NSError *) in snapshot) {
        callback(response, nil);
    }

    // All callbacks receive the exact same response object
    XCTAssertEqual(response1, response2, @"All callbacks should receive the same response object");
    XCTAssertEqual(response2, response3, @"All callbacks should receive the same response object");
    XCTAssertEqualObjects(response1.params[@"test_key"], @"test_value");
}

- (void)testCallbacksNotRetainedAfterDispatch {
    NSMutableArray *callbacks = [self.branch valueForKey:@"pendingSessionCallbacks"];
    [callbacks removeAllObjects];

    void (^cb)(BNCInitSessionResponse *, NSError *) = ^(BNCInitSessionResponse *r, NSError *e) {};
    [callbacks addObject:[cb copy]];

    XCTAssertEqual(callbacks.count, 1);

    // Copy and clear (simulates production pattern)
    NSArray *snapshot = [callbacks copy];
    [callbacks removeAllObjects];

    XCTAssertEqual(callbacks.count, 0, @"Callbacks should not be retained in the array after clear");
    XCTAssertEqual(snapshot.count, 1, @"Snapshot should have the callback for dispatch");
}

@end
