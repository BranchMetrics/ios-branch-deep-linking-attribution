//
//  BNCServerRequestOperation.m
//  BranchSDK
//
//  Created by Nidhi Dixit on 7/22/25.
//  Updated: Modern Swift Concurrency bridge
//

#import "Private/BNCServerRequestOperation.h"
#import "BranchOpenRequest.h"
#import "BranchInstallRequest.h"
#import "BranchEvent.h"
#import "BranchLogger.h"
#import "NSError+Branch.h"
#import "BNCCallbackMap.h"

// Swift integration - BranchSwiftSDK module is loaded dynamically at runtime
// No compile-time import needed to avoid circular dependencies in SPM
#if !SWIFT_PACKAGE
// Swift bridging header - auto-generated by Xcode when Swift files are present
#if __has_include("BranchSDK/BranchSDK-Swift.h")
#import "BranchSDK/BranchSDK-Swift.h"
#endif
#endif

@interface BNCServerRequestOperation ()
@property (nonatomic, assign, readwrite, getter = isExecuting) BOOL executing;
@property (nonatomic, assign, readwrite, getter = isFinished) BOOL finished;
@property (nonatomic, strong, nullable) id swiftOperation; // BranchRequestOperation for iOS 13+
@end

@implementation BNCServerRequestOperation {
    BNCServerRequest *_request;
}

@synthesize executing = _executing;
@synthesize finished = _finished;

- (instancetype)initWithRequest:(BNCServerRequest *)request {
    self = [super init];
    if (self) {
        _request = request;
        _executing = NO;
        _finished = NO;
    }
    return self;
}

- (BOOL)isAsynchronous {
    return YES;
}

 /*TODO - This can be used for initSafetyCheck and adding dependencies
- (BOOL)isReady {
    BOOL ready = [super isReady];
    if (ready) {
        
    }
    return ready;
}*/

- (void)setExecuting:(BOOL)executing {
    [self willChangeValueForKey:@"isExecuting"];
    _executing = executing;
    [self didChangeValueForKey:@"isExecuting"];
}

- (void)setFinished:(BOOL)finished {
    [self willChangeValueForKey:@"isFinished"];
    _finished = finished;
    [self didChangeValueForKey:@"isFinished"];
}

- (void)start {
    // Use modern Swift Concurrency implementation on iOS 13+
    if (@available(iOS 13.0, tvOS 13.0, *)) {
        if ([self shouldUseSwiftImplementation]) {
            [self startWithSwiftOperation];
            return;
        }
    }

    // Fallback to legacy Objective-C implementation
    [self startObjectiveCOperation];
}

#pragma mark - Swift Concurrency Bridge (iOS 13+)

- (BOOL)shouldUseSwiftImplementation API_AVAILABLE(ios(13.0), tvos(13.0)) {
    // Enable Swift implementation by default on supported platforms
    // Can be controlled by feature flag if needed
    return YES;
}

- (void)startWithSwiftOperation API_AVAILABLE(ios(13.0), tvos(13.0)) {
    // Create Swift operation with modern async/await
    // Try module-qualified name first, then unqualified name
    Class swiftOperationClass = NSClassFromString(@"BranchRequestOperation");
    if (!swiftOperationClass) {
        swiftOperationClass = NSClassFromString(@"Branch.BranchRequestOperation");
    }
    if (!swiftOperationClass) {
        swiftOperationClass = NSClassFromString(@"BranchSDK.BranchRequestOperation");
    }
    if (!swiftOperationClass) {
        [[BranchLogger shared] logWarning:@"BranchRequestOperation (Swift) not available. Falling back to Objective-C implementation." error:nil];
        [self startObjectiveCOperation];
        return;
    }

    // Initialize Swift operation
    SEL initSelector = NSSelectorFromString(@"initWithRequest:serverInterface:branchKey:preferenceHelper:");

    // Allocate instance first
    id swiftInstance = [swiftOperationClass alloc];

    // Check if instance responds to initializer
    if (![swiftInstance respondsToSelector:initSelector]) {
        [[BranchLogger shared] logWarning:@"BranchRequestOperation initializer not found. Falling back to Objective-C implementation." error:nil];
        [self startObjectiveCOperation];
        return;
    }

    BNCPreferenceHelper *preferenceHelper = self.preferenceHelper ?: [BNCPreferenceHelper sharedInstance];

    // Create Swift operation using dynamic invocation
    NSMethodSignature *signature = [swiftInstance methodSignatureForSelector:initSelector];
    if (!signature) {
        [[BranchLogger shared] logWarning:@"Could not get method signature for Swift initializer. Falling back to Objective-C implementation." error:nil];
        [self startObjectiveCOperation];
        return;
    }

    NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];
    [invocation setSelector:initSelector];
    [invocation setTarget:swiftInstance];
    [invocation setArgument:&_request atIndex:2];
    [invocation setArgument:&_serverInterface atIndex:3];
    [invocation setArgument:&_branchKey atIndex:4];
    [invocation setArgument:&preferenceHelper atIndex:5];
    [invocation invoke];

    void *tempResult = NULL;
    [invocation getReturnValue:&tempResult];
    self.swiftOperation = (__bridge_transfer id)tempResult;

    if (!self.swiftOperation) {
        [[BranchLogger shared] logWarning:@"Failed to create Swift operation. Falling back to Objective-C implementation." error:nil];
        [self startObjectiveCOperation];
        return;
    }

    // Forward operation lifecycle to Swift implementation
    SEL startSelector = NSSelectorFromString(@"start");
    if ([self.swiftOperation respondsToSelector:startSelector]) {
        [self.swiftOperation performSelector:startSelector];
    }

    // Monitor Swift operation state and reflect in Objective-C operation
    [self observeSwiftOperation];
}

- (void)observeSwiftOperation API_AVAILABLE(ios(13.0), tvos(13.0)) {
    // Add KVO observers for Swift operation state
    [self.swiftOperation addObserver:self
                          forKeyPath:@"isExecuting"
                             options:NSKeyValueObservingOptionNew
                             context:nil];
    [self.swiftOperation addObserver:self
                          forKeyPath:@"isFinished"
                             options:NSKeyValueObservingOptionNew
                             context:nil];
}

- (void)observeValueForKeyPath:(NSString *)keyPath
                      ofObject:(id)object
                        change:(NSDictionary<NSKeyValueChangeKey,id> *)change
                       context:(void *)context {
    if (object == self.swiftOperation) {
        if ([keyPath isEqualToString:@"isExecuting"]) {
            self.executing = [[change objectForKey:NSKeyValueChangeNewKey] boolValue];
        } else if ([keyPath isEqualToString:@"isFinished"]) {
            self.finished = [[change objectForKey:NSKeyValueChangeNewKey] boolValue];
            // Clean up observers when finished
            if (self.swiftOperation) {
                [self.swiftOperation removeObserver:self forKeyPath:@"isExecuting"];
                [self.swiftOperation removeObserver:self forKeyPath:@"isFinished"];
                self.swiftOperation = nil;
            }
        }
    }
}

#pragma mark - Legacy Objective-C Implementation

- (void)startObjectiveCOperation {
    if (self.isCancelled) {
        [[BranchLogger shared] logDebug:[NSString stringWithFormat:@"Operation cancelled before starting: %@", self.request.requestUUID] error:nil];
        self.finished = YES;
        return;
    }

    self.executing = YES;
    [[BranchLogger shared] logVerbose:[NSString stringWithFormat:@"BNCServerRequestOperation (Objective-C) starting for request: %@", self.request.requestUUID] error:nil];

    // Check if tracking is disabled
    if (Branch.trackingDisabled) {
        [[BranchLogger shared] logDebug:[NSString stringWithFormat:@"Tracking disabled. Skipping request: %@", self.request.requestUUID] error:nil];
        self.executing = NO;
        self.finished = YES;
        return;
    }

    BNCPreferenceHelper *preferenceHelper = self.preferenceHelper ?: [BNCPreferenceHelper sharedInstance];

    //  Session validation for requests
    if (!([self.request isKindOfClass:[BranchInstallRequest class]])) {
        if (!preferenceHelper.randomizedBundleToken) {
            [[BranchLogger shared] logError:[NSString stringWithFormat:@"User session not initialized (missing bundle token). Dropping request: %@", self.request.requestUUID] error:nil];
            BNCPerformBlockOnMainThreadSync(^{
             [self.request processResponse:nil error:[NSError branchErrorWithCode:BNCInitError]];
             });
            self.executing = NO;
            self.finished = YES;
            return;
        }
    } else if (!([self.request isKindOfClass:[BranchOpenRequest class]])) {
        if (!preferenceHelper.randomizedDeviceToken || !preferenceHelper.sessionID || !preferenceHelper.randomizedBundleToken) {
            [[BranchLogger shared] logError:[NSString stringWithFormat:@"Missing session items (device token or session ID or bundle token). Dropping request: %@", self.request.requestUUID] error:nil];
            BNCPerformBlockOnMainThreadSync(^{
                [self.request processResponse:nil error:[NSError branchErrorWithCode:BNCInitError]];
             });
            self.executing = NO;
            self.finished = YES;
            return;
        }
    }

    // TODO: Handle specific `BranchOpenRequest` lock
    // `waitForOpenResponseLock` will block the current thread (the NSOperation's background thread)
    // until the global open response lock is released. This ensures proper sequencing
    // if another init session is in progress.
    /* if ([self.request isKindOfClass:[BranchOpenRequest class]]) {
        [[BranchLogger shared] logDebug:[NSString stringWithFormat:@"BranchOpenRequest detected. Waiting for open response lock for %@", self.request.requestUUID] error:nil];
        [BranchOpenRequest waitForOpenResponseLock];
    }*/

    [self.request makeRequest:self.serverInterface
                          key:self.branchKey
                     callback:^(BNCServerResponse *response, NSError *error) {
        BNCPerformBlockOnMainThreadSync(^{
            [self.request processResponse:response error:error];
            if ([self.request isKindOfClass:[BranchEventRequest class]]) {
                [[BNCCallbackMap shared] callCompletionForRequest:self.request withSuccessStatus:(error == nil) error:error];
            }
        });
            [[BranchLogger shared] logVerbose:[NSString stringWithFormat:@"BNCServerRequestOperation (Objective-C) finished for request: %@", self.request.requestUUID] error:nil];
            self.executing = NO;
            self.finished = YES;

    }];
}

- (void)cancel {
    [super cancel]; // Sets `isCancelled` to YES

    // Forward cancellation to Swift operation if active
    if (@available(iOS 13.0, tvOS 13.0, *)) {
        if (self.swiftOperation) {
            SEL cancelSelector = NSSelectorFromString(@"cancel");
            if ([self.swiftOperation respondsToSelector:cancelSelector]) {
                [self.swiftOperation performSelector:cancelSelector];
            }
        }
    }

    if (!self.isExecuting) {
        self.finished = YES;
        [[BranchLogger shared] logWarning:[NSString stringWithFormat:@"BNCServerRequestOperation cancelled before execution for request: %@", self.request.requestUUID] error:nil];
    } else {
        [[BranchLogger shared] logWarning:[NSString stringWithFormat:@"BNCServerRequestOperation cancelled during execution for request: %@", self.request.requestUUID] error:nil];
    }
}

static inline void BNCPerformBlockOnMainThreadSync(dispatch_block_t block) {
    if (block) {
        if ([NSThread isMainThread]) {
            block();
        } else {
            dispatch_sync(dispatch_get_main_queue(), block);
        }
    }
}

@end
